//slightly modified rust style struct declaration 
struct S {
    a: u32;
    b: u32*;
}



//modified rust style fn
do_nothing: fn(a: u32) -> u32 = {
    a
}

//functions with a single expression can be written as such
add: fn(x: i32, y: i32) -> i32 = x + y;
add: fn(x: i32, y: i32) = x + y; //it can infer the return type

//should I allow associated methods? or use c-style and pass pointers to functions
//  idea: assign anonymous function to function pointer field of struct
struct AssocMethod {
	some_fn: Fn(i32, i32) -> i32; //fn pointer syntax
	some_data: i32;
}

AssocMethod::some_fn: fn(x: i32, y: i32) = x + y;

//implicitly pass a self pointer when calling such associated methods
//e.g.
//let s = AssocMethod{...};
//s.can_access_self()
//same as
//AssocMethod::can_access_self(s&);
AssocMethod::can_access_self: fn(self: AssocMethod*) = self.some_data;



//rust style error handling 
//not sure about this generic syntax, i want genetics to be as simple as possible though 
#[generic(T)]
union Option {
    Some: T;
    None;
}

//perhaps implicitly like ths
union Option<T> {
	Some: T;
	None;
}

can_fail: fn() -> Option<i32> = None
can_fail: fn() -> Option<i32> = {
	None
}

handle_fail: fn() -> Option<i32> = {
	let res_a = can_fail()?; //rust style ? syntax
	let res_b = can_fail()?;
	Some(a + b)
}

main: proc() -> i32 = {
    let a: u32 = 32;
    let b = &a; //b is pointer not reference because pointers are based
    let c: u8[4] /* is [u8; 4] better? */ = *b;

    //ifs are expressions
    let d = if c[0] { a * 2 } else { a / 2 };

    //optional parens?
    let d = do_nothing 15;
	
	//lambdas
	let a_fn: Fn() -> i32 = fn() = 32;
	//or just
	let a_fn = fn() = 32;
	//idk about the two =s though. they look a bit unclean;
	
	0 //success from main
}


//procs can have side effects
//fns are pure functions
//procs can call procs or fns
//fns can only call fns
something: fn() = {
	putd(6); //ERROR: can't call proc from fn
}


//eating??
split_eat: fn(a: eats String*) -> Vec<String> = {
	//doesn't preserve data in `a`
	//use of whatever was passed to the fn is prohibited
}

split_copy: fn(a: String*) -> Vec<String> = {
	//here whatever struct `a` was must still be valid later
}

foo: fn() = {
	let str = String::from_static("asd");
	let splits = str.split_eat();
	putstr(str&); //ERROR: use after eat
}
